# 转生成为 C 语言糕手——进阶篇

## A 复读机！

### 题目描述

是该沙漠太喜欢水群了！作为 "移动软件 23 级 1-3 班 C 语言课程群" 的管理员，他每天都会点进群里很多次，所以他总是能看到群主朱会东老师发表的一些比较有意思的发言

当然，是该沙漠同学也是很喜欢朱老师说的这些话的，所以，可以把**其中任意一句话**复述给是该沙漠同学听吗？

<img src="C:\Users\21274\Desktop\pic3.png" alt="pic3" style="zoom:50%;" />

### 输入

无

### 输出

直接复述朱老师的任意一句完整发言（不含表情包及图片内的文字）

注意段间换行需要全部写进去，段内折行不需要单独换行，判题时忽略行尾换行。

### 提示

注意换行及标点符号，标点**均为中文全角符号**

**本题仅判定输出的前 2000 个字符的内容，多余内容无效，将会被忽略。**

使用 Python 提交时，请在代码最前面加上 `#! /bin/usr/python2` 以防空输出

**本题仅判定第一行输出内容，多余的输出无效，多于 2000 字符的输出将被截断**

### 题解

本题使用了 Special Judge，下面 20 条发言随便选择一条输出即可，记得把换行改为空格！

```markdown
@全体成员 同学们，没事的时候大家可以先了解一下编程，本学期我将带领大家一起感受程序设计的魅力，领略编程之美
```

```markdown
学计算机编程究竟是学什么呢？答案是逻辑思维和编程思维。
学习了计算机编程，思考问题的方式变得非常逻辑化，学会了严密的逻辑推理方法，并无形中把它应用到其他学科的学中。
学习计算机编程本质上是在学习一种思维方式——编程思维，它是一种思维体操。
```

```markdown
学习计算机编程的过程充满乐趣。如果你有一个想法，马上就可以通过编程来实现，只有想不到的，没有做不到的。
```

```markdown
现在开始自己动手编程，不要放弃曾经的梦想，大胆地创造你的作品。
```

```markdown
@岁寒途远 还以为你是学长呢，原来你真是23级的
```

```markdown
计算机很傻很较真，它非常听话，但是你要把话说的非常明白，事无巨细他才能帮你做事情，我们与计算机交流时要逻辑严谨周密，这样计算机才不会做错事、傻事。

举个例子
你是老板，让你的秘书帮你泡杯茶，你要交代说的特别明白，茶壶在桌子上面，茶叶在第二个抽屉的红色盒子里，先把2克茶叶先放进茶壶中，倒入800毫升的开水，浸泡3分钟，给我送过来。
在这问题中，我们看出交代事情不要让她猜你的意思，需要量化的就要量化，需要指定先后顺序的要指定先后顺序，交代的一清二楚，秘书还会做错吗？
```

```markdown
我希望在上第一节编程课的时候，每一位同学都能从门外走到门里，不要再做一个门外汉
```

```markdown
想用电脑打游戏的同学，最好买个3000块钱的电脑
```

```markdown
不管你在学校，在家中，还是在旅途中，当酒足饭饱后，打开OJ平台，深吸一口气，敲出一段程序，仿佛进入了计算机世界，忘记了人世间的冷落辛酸，轻点提交按钮，慢慢等待那一抹绿色的出现，舒了一口气，顿时视觉和精神上都得到极大满足。
```

```markdown
运动了一小时，倒上一杯水，打开电脑，噼里啪啦敲一段代码，记录自己的思路和想法，生活相当惬意
```

```markdown
爱就一个字，我只说一次，刷题是两个字，我再说一次
```

```markdown
小伙伴们，假期过半了，想着我点
```

```markdown
风里雨里我在这里等你，云里雾里编程的世界不能没有你
```

```markdown
年轻人，就是要对自己狠一点
```

```markdown
望穿秋水的等待，来吧
```

```markdown
喜欢打游戏的同学，先在OJ上刷个十道八道题找找感觉
```

```markdown
在写代码的时候，一定问一下自己：
这条语句想让计算机做什么事情？
计算机能不能理解语句的意思？
```

```markdown
下周上课的时侯，如果有同学还一题没做，有必要打一顿！
```

```markdown
赢了我，在校内最好的饭店请你吃一顿
```

```markdown
我隐隐约约感觉有同学已经沉迷于游戏
```

不知道你发现没有，输出 "其中任意一句话" 也可通过本题，本题代码比较简单，就不放出来了

## B 运气 or 实力

### 题目描述

在高中时期，大家肯定是经常做选择题。而在面对选择题的时候，Zero 有两种解决办法给出他的答案：运气 or 实力。
本道题目为选择题，你会如何选择来给出你的答案。

从公元 1001 年到公元 2023 年，一共有多少个闰年？

### 输入

无

### 输出

一个整数，代表闰年的个数

### 样例输出

```markdown
240 ~ 250 之间的某个数字
```

### 题解

- 一个很容易想到的方法就是枚举这些年份，然后判断是否是闰年并记录闰年的个数

```c
#include <stdio.h>

int main() {
    int ans = 0;
    for (int i = 1001; i <= 2023; i++) {
        if ((i % 4 == 0 && i % 100 != 0) || i % 400 == 0) {  // 闰年判断方法
            ans++;
        }
    }
    printf("%d", ans);
    return 0;
}
```





## C 实力为王

### 题目描述

不是所有题目都有选项，想要获得胜利，实力为王。
本道题目为填空题，请靠实力说话。

在打竞技类游戏的时候，匹配系统会尽可能给你匹配到旗鼓相当的对手。Zero 认为你已经有这个能力实现这个匹配功能，现在你需要思考如何给玩家匹配水平相近的对手，并且实现它。

### 输入

第一行一个正整数 $n$ $(~n~\le~3000~)$

接下来一行有 $n$ 个正整数 $x$ $(~x~\le~10^9~)$，代表 $n$ 个玩家的实力值

最后一行一个正整数 $m$ $(~m~\le~1e9~)$，代表实力值为 $m$ 的玩家 Zero 等待匹配

### 输出

一个整数，代表与 Zero 实力值最为接近的玩家的实力值

如果有实力相差相同的玩家，请输出最早出现的玩家的实力值

### 样例输入

```markdown
10
1 10 100 1000 10000 100000 1000000 10000000 100000000 1000000000
998244353
```

### 样例输出

```markdown
1000000000
```

### 题解

- 实力相近是指两个人的实力差的绝对值小，那我们只需要求最小的实力差

```c
#include <stdio.h>
#include <math.h>
int a[3010];

int main() {
    int n, m;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    }
    scanf("%d", &m);
    int dt = 1000000000, ans = 1;  // dt 是目前最小的实力差， ans 是最小实力差对应的那个人的实力
    for (int i = 1; i <= n; i++) {
        if (abs(m - a[i]) < dt) {  // 如果后面的人出现了更小的实力差，更新 dt 和 ans
            dt = abs(m - a[i]);
            ans = a[i];
        }
    }
    printf("%d", ans);
    return 0;
}
```





## D 入度和出度 —— 菜姬的算法小课堂

### 题目描述

***菜姬的算法小课堂开课了！！！***今天，菜姬老师给大家讲的内容是 "入度和出度"。

"入度和出度" 的定义：**节点（顶点）的 入度 是指进入该节点（顶点）的边的条数； 节点（顶点）的 出度 是指从该节点（顶点）出发的边的条数**。

"入度和出度" 是图论题面中经常会用到的知识，今天，菜姬老师想带领大家解决一个最基本的问题："如何统计入度和出度"

要解决这个问题我们还需要先学习一个新概念 "有向边"，毕竟图论问题都是以点和边为基础构造的。那么，什么是有向边呢？

"有向边"的定义：**有向边是图中的一种边，它具有方向。每条有向边连接两个顶点，并且从一个顶点指向另一个顶点。在有向图中，每条边都是有方向的，因此我们可以将其表示为一个有序对 $(u,~v)$，其中 $u$ 是起始点，$v$ 是终端点。**

知道了这两个概念，我们也就可以开始解决这个基础的问题了。那么，现在让我们丰富一下题面从而方便大家阅读这个问题吧。

现在这里存在 $n$ 个节点，节点和节点之间可能具有边（有向边），接下来给我们 $m$ 条边，边的形式以有序对 $(u,~v)$ 给出。我们需要统计每个点的入度和出度，之后统一输出。

### 输入

第一行输入两个整数 $n,~m$ $(~1\le n,~m\le10^5~)$。

接下来 $m$ 行每行给定两个值 $u,~v$ $(~1\le u,~v\le n~)$ 分别代表端点编号

**数据不存在自环**

### 输出

输出 $n$ 行数据，输出每个端点的出度和入度，输出格式如样例。

（若该点无入度或出度请输出数字 0）

### 提示

对于 (1, 2) 边，该边是由节点 1 到节点 2 的一条有向边，那么点 1 的出度加 1，点 2 的入度加 1。其它边同理。

本题实现方式并不困难，难点在于对新概念的快速学习和理解。编程的学习就是这样，如果你学习吸收新知识新概念的能力很弱，就很难解决很多问题，哪怕这些问题的实现方式其实很简单。当然如果并不理解本题请不要气馁，对于新手来说编程思维和高中时的学习思维还是有很大差距，一时半会儿没转变过来很正常（大家智商其实都大差不差哦），但是请不要放弃，努力培养自己的编程思维是很有必要的，从0到1很难，从1到2就不会那么困难了。所以，加油吧，同学！！！

### 样例输入

```markdown
5 3
1 2
2 3
3 4
```

### 样例输出

```markdown
1 0
1 1
1 1
1 0
0 0
```

### 题解

先输出出度，然后再输出入度哟

- C

```c
#include <stdio.h>
int n, m, in[100010], out[100010];  // in，out数组分别为入度和出度数组

int main() {
    scanf("%d%d", &n, &m);
    while (m--) {
        int u, v;
        scanf("%d%d", &u, &v);
        // 由 u 到 v 的一条边，即从 u 出向 v 入，u 点的出度 +1，v 点的入度 +1
        in[v]++, out[u]++;
    }
    for (int x = 1; x <= n; x++)
        printf("%d %d\n", out[x], in[x]);
    return 0;
}
```

- C++

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, in[100010], out[100010];  // in，out数组分别为入度和出度数组

int main() {
    cin >> n >> m;
    while (m--) {
        int u, v;
        cin >> u >> v;
        // 由 u 到 v 的一条边，即从 u 出向 v 入，u 点的出度 +1，v 点的入度 +1
        in[v]++, out[u]++;
    }

    for (int x = 1; x <= n; x++) {
        cout << out[x] << ' ' << in[x] << '\n';
    }
    return 0;
}
```



## E 菜姬不喜欢排队！！！

### 题目描述

"天天上课坐电梯排队，去食堂吃饭也要排队，买东西也要排队，怎么大家都这么喜欢排队呀？啊啊啊~菜姬酱实在是受不了一点辣！！！"

众所周知，菜姬特别讨厌排队，而且可爱的菜姬还是个坏东西，特别喜欢对队首的同学发出恶意（菜姬也想排第一个！！！），今天菜姬又又又排上了队，可怜的菜姬再次发出了无能狂怒。

队伍中有 $n$ 位同学（显然不包括菜姬，菜姬肯定是在队伍最后哒~），接下来给出 $n-1$ 个前后关系，我们以有序对 $(u,~v)$ 表示。$u$ 同学在 $v$ 同学后面（挨着的哦），同学的编号属于 $[1,~n]$ 且不会重复。显然 $n-1$ 对有序对能涵盖队伍的所有相邻的前后关系。

聪明的你能回答菜姬到底对队伍里的哪位同学恶意最大吗？

### 输入

第一行输入一个正整数 $n$ $(~1\le n\le 10^5~)$ 表示同学数量

接下来 $n-1$ 行，每行输入两个数 $u,~v$ $(~1\le u,~v\le n~)$ 代表相邻同学关系。

### 输出

输出一个正整数，表示菜姬恶意最大同学的编号。

### 提示

本题可运用 "入度和出度" 知识呦。所以聪明的同学们能想到该怎么解决吗？大家加油哦~（菜姬酱加油助威！！！）

### 样例输入

```markdown
5
1 2
2 3
3 4
4 5
```

### 样例输出

```markdown
5
```

### 题解

本题可将每一个前后关系转化为一条边，后面的同学向前面的同学连一条边，那么最开头的同学的出度肯定为 0（因为该同学前面并无其他同学，统计出度时该同学不统计在内）

- C

```c
#include <stdio.h>
int n, res, out[100010];

int main() {
    scanf("%d", &n);
    for (int x = 1; x <= n - 1; x++) {
        int u, v;
        scanf("%d%d", &u, &v);
        // 统计出度
        out[u]++;
    }

    for (int x = 1; x <= n; x++) {
        if (out[x] == 0) {
            printf("%d\n", x);
            break;
        }
    }
    return 0;
}
```

- C++

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, res, out[100010];

int main() {
    cin >> n;
    for (int x = 1; x <= n - 1; x++) {
        int u, v;
        cin >> u >> v;
        // 统计出度
        out[u]++;
    }
    for (int x = 1; x <= n; x++) {
        if (out[x] == 0) {
            cout << x << '\n';
            break;
        }
    }
    return 0;
}
```



## F 前缀和 —— 菜姬的算法小课堂

### 题目描述

***菜姬的算法小课堂开课了！！！***今天，菜姬老师给大家讲的内容是“前缀和”。

"前缀和" 的定义：**数列的前 $n$ 项的和。**

前缀和是一种重要的预处理，能大大降低查询的时间复杂度。 我们可以简单理解为 **"数列的前 $n$ 项的和"**。 这个概念其实很容易理解，即一个前缀和数组中，第 $n$ 位存储的是原数组前 $n$ 个数字的和。

在这里我默认大家对高中的数学基本知识还有印象，那么前缀和以高中学的数列来表示就是 $S_n = \textstyle \sum_{i=1}^{n} a_i$

当然，在编程里我们不需要记忆什么求和公式，而且基本上所有前缀和（一维）的求解形式都是一样的。

形式来讲，假如我们有一个长度为 $n$ 的数组 $a$，数组 $a$ 的每一项都有一个初始值，那么求解这个数组的前缀和方式为：

**使用 for 循环从前往后遍历，对于当前下标 $x$，我们需要进行** `a[x] += a[x - 1]` **操作，这样循环下来就能取得数组的前缀和数组，通俗来说对于一个初始的数组，如果我们需要求解前缀和数组第 $x$ 项，那么这个第 $x$ 项显然值为原数组 $a$ 的前 $x$ 项和，即我们求解时可以用原数组 $a$ 前 $x-1$ 项和加上我们 $a$ 数组第 $x$ 项。**

当然以上求出的前缀和数组会覆盖原数组 $a$，如果大家想保留原数组我们可以用新数组 $S$ 代码前缀和数组。同理，求解 $S$ 的方式类似，我们只需要进行 `S[x] = S[x - 1] + a[x]`，需要注意的是 $S_1=a_1$。

总而言之，本节并不是想让大家具体掌握前缀和知识，只是想提前让大家了解一下。因此，我们的问题相对来说会很简单。那么来让我们练练手吧：

假设我们有一个长度为 $n$ 的数组，请求出数组的前缀和数组，并输出每一项。

### 输入

第一行输入一个 $n$ $(~1\le n\le 10^5~)$

接下来有 $n$ 行，每一行输入一个整数 $a_i$

保证 $\textstyle \sum_{i=1}^{n}a_i \le 2 \times 10^9$

### 输出

输出 $n$ 行，第 $i$ 行输出前缀和数组第 $i$​ 项。

### 提示

本题实现难度非常简单，前缀和的概念也不是很复杂，如若不懂，可自行百度。

### 样例输入

```markdown
4
1
1
1
1
```

### 样例输出

```markdown
1
2
3
4
```

### 题解

- C

```c++
#include <stdio.h>
int n, a[100010];

int main() {
    scanf("%d", &n);
    for (int x = 1; x <= n; x++) {
        scanf("%d", &a[x]);
    }

    for (int x = 2; x <= n; x++) {
        a[x] += a[x - 1];
    }

    for (int x = 1; x <= n; x++) {
        printf("%d\n", a[x]);
    }
    return 0;
}
```

- C++

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[100010];

int main() {
    cin >> n;
    for (int x = 1; x <= n; x++) {
        cin >> a[x];
    }

    for (int x = 2; x <= n; x++) {
        a[x] += a[x - 1];
    }

    for (int x = 1; x <= n; x++) {
        cout << a[x] << '\n';
    }
    return 0;
}
```



## G 坐地铁！(Easy Version)

### 题目描述

是该沙漠同学去广州旅游了，当他到达广州南站地铁站的时候，他看着广州错综复杂的地铁网感到了迷茫，请帮他算一下他某一次行程的最低车票支出

下面是广州地铁票务规则中有关票价及日票的部分内容

- 广州地铁线网票价按里程分段计价：
  起步 4 公里以内 2 元；
  4 至 12 公里范围内每递增 4 公里加 1 元；
  12 至 24 公里范围内每递增 6 公里加 1 元；
  24 公里以后，每递增 8 公里加 1 元。

- 乘客可在广州地铁线网任一车站购买日票。
  一日票：乘客持一日票首次进闸起 24 小时内可不限次数、距离及线路乘坐地铁，每张 20 元。
  三日票：乘客持三日票首次进闸起 72 小时内可不限次数、距离及线路乘坐地铁，每张 50 元。

为了简化题目，本题只考虑起点和终点都在同一条线路的情况，不考虑换乘、支线、环线等复杂情况
不考虑通过其他线路可以缩短路程的可能性，不考虑当天后续的行程对当前行程的影响
**假定所有行程都能在 24 小时内完成**

![pic](C:\Users\21274\Desktop\pic1.png)

### 输入

第一行输入一个整数 $n$ $(~1~\le~n~\le~10^5~)$ ，代表线路上的站点数

第二行输入 $n-1$ 个实数 $a_1,~a_2,~a_3,~...,~a_{n-1}$ $(~a_i~>~0~)$ ，$a_i$ 代表区间 $a_i$ 到 $a_{i+1}$ 的距离（其中 $i$ 代表站点编号，单位为公里）

第三行输入一个整数 $q$ $(~1~\le~q~\le~10^5~)$ ，代表查询的次数，每次查询是独立的

接下来 $q$ 行，每行两个整数 $x,~y$ $(~1~\le~x,~y~\le~n~)$ ，分别代表是该沙漠同学某次行程起点和终点的站点编号（不包含前导 0）

### 输出

输出 $q$ 行，每行一个整数 $p$，即是该沙漠同学当次行程需要支付的最小金额

### 提示

保证 $\textstyle\sum_{i=1}^{n-1} a_i\le10^9$

在地铁票务系统中，不足 x 公里按 x 公里计算（如 5 公里的票价为 3 元）

**请使用 double 类型而非 float 类型以避免精度问题**

对于 Python 的提交，请使用 `sys.stdin` 读入，否则可能会时间超限

### 样例输入

```markdown
8
7.8 25.8 9.3 3.8 5.1 2.1 3.9
4
1 8
2 3
2 8
7 8
```

### 样例输出

```markdown
11
7
10
2
```

### 题解

用前缀和数组来记录区间长度可以让我们在 O(1) 的时间复杂度下求得某两个点中间的区间总长度

为了方便，我们定义一个 `cal()` 函数来计算某一距离所对应的票价

我们这里使用 `math.h` 库中的 `ceil()` 函数让票价向上取整（即不足 x 公里按 x 公里计算的实现）

使用三目运算符 `a < b ? a : b` 来求 $a$ 与 $b$ 的最小值

当单程票票价超过日票票价时，显然购买日票是更实惠的方案，故让计算出的票价与 20 取最小值输出即可

```c
#include <math.h>
#include <stdio.h>
double a[100010];

int cal(double len) {
    // 计算票价
    int ans = 2;
    if (len > 24) {
        ans = 6 + ceil((len - 24) / 8);
    } else if (len > 12) {
        ans = 4 + ceil((len - 12) / 6);
    } else if (len > 4) {
        ans = 2 + ceil((len - 4) / 4);
    }
    return ans;
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 2; i <= n; i++) {
        scanf("%lf", &a[i]);
        // 前缀和
        a[i] += a[i - 1];
    }

    int q;
    scanf("%d", &q);
    while (q--) {
        int x, y;
        scanf("%d%d", &x, &y);

        // 利用前缀和数组计算区间长度
        double len = fabs(a[x] - a[y]);
        int ans = cal(len);

        // 价格超过 20 元，购买一日票更实惠
        ans = ans < 20 ? ans : 20;
        printf("%d\n", ans);
    }
    return 0;
}
```



## H 坐地铁！(Hard Version)

### 题目描述

**请先阅读 "坐地铁！(Easy Version)" 再来作答此题！**

是该沙漠同学打算在广州游玩 3 天，他已经规划好 3 天的路线了！为了环(sheng)保(qian)，他还是选择搭乘地铁出行

所以乘坐地铁购票的时候有以下几种选择：

- 3 天所有行程购买均单程票
- 其中任意 1 天或 2 天购买相应张数一日票，剩余 2 天或 1 天购买单程票
- 购买一张三日票

是该沙漠同学不会算数，但是他又想选择一种最省钱的方案，这复杂的计算可把他给绕晕了捏
为了简化问题，我们规定**单日票次日 0 点自动失效，第二天不可继续使用**

计费规则同 "坐地铁！(Easy Version)" ，故本题不再赘述

![pic](C:\Users\21274\Desktop\pic2.png)

### 输入

第一行输入一个整数 $n$ $(~1~\le~n~\le~10^5~)$ ，代表线路上的站点数

第二行输入 $n-1$ 个实数 $a_1,~a_2,~a_3,~...,~a_{n-1}$ $(~a_i~>~0~)$ ，$a_i$ 代表区间 $a_i$ 到 $a_{i+1}$ 的距离（其中 $i$ 代表站点编号，单位为公里）

第三行输入三个整数 $t_1,~t_2,~t_3$ $(~t_1,~t_2,~t_3~\ge~0$ 且 $t_1+t_2+t_3~\le~10^5~)$ ，分别代表是该沙漠同学每天要搭乘几次地铁

接下来 $t_1$ 行，每行两个整数 $x,~y$ $(~1~\le~x,~y~\le~n~)$ ，分别代表是该沙漠同学第 1 天某次行程起点和终点的站点编号

接下来 $t_2$ 行，每行两个整数 $x,~y$ $(~1~\le~x,~y~\le~n~)$ ，分别代表是该沙漠同学第 2 天某次行程起点和终点的站点编号

接下来 $t_3$ 行，每行两个整数 $x,~y$ $(~1~\le~x,~y~\le~n~)$ ，分别代表是该沙漠同学第 3 天某次行程起点和终点的站点编号

所有站点编号均不包含前导 0

### 输出

如果是该沙漠同学三天都没出门（即三天都没有行程），请输出 `Lazy, SkySummer!` 3 遍（每次一行）

否则输出一行一个整数 $p$，即是该沙漠同学这 3 天搭乘地铁的最低车票支出

### 提示

请注意输入格式！

保证 $\textstyle\sum_{i=1}^{n-1} a_i\le10^9$

保证全部行程的单程票票价总和不超过 $10^{10}$

### 样例输入

```markdown
5
1.2 1.2 1.2 1.2
1 1 1
1 2
2 3
3 4
```

### 样例输出

```markdown
6
```

### 题解

数据范围 $10^{10}$，使用 `int` 类型可能会溢出，记得开 `long long`

为了方便，我们定义一个 `min()` 函数来计算两个数的最小值

没有出门的情况下不要忘了输出 `Lazy, SkySummer!`

本题需要讨论的情况不多，也可以枚举每种购买日票的方案最后取最小值输出

```c
#include <math.h>
#include <stdio.h>
double a[100010];

int cal(double len) {
    // 计算票价
    int ans = 2;
    if (len > 24) {
        ans = 6 + ceil((len - 24) / 8);
    } else if (len > 12) {
        ans = 4 + ceil((len - 12) / 6);
    } else if (len > 4) {
        ans = 2 + ceil((len - 4) / 4);
    }
    return ans;
}

long long min(long long x, long long y) {
    // 求最小值
    return x < y ? x : y;
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 2; i <= n; i++) {
        scanf("%lf", &a[i]);
        // 前缀和
        a[i] += a[i - 1];
    }

    int t1, t2, t3;
    scanf("%d%d%d", &t1, &t2, &t3);

    // 分别计算每一天的票价，决定当天是否购买日票
    long long cost1 = 0;
    for (int i = 1; i <= t1; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        double len = fabs(a[x] - a[y]);
        cost1 += cal(len);
    }
    cost1 = min(cost1, 20);

    long long cost2 = 0;
    for (int i = 1; i <= t2; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        double len = fabs(a[x] - a[y]);
        cost2 += cal(len);
    }
    cost2 = min(cost2, 20);

    long long cost3 = 0;
    for (int i = 1; i <= t3; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        double len = fabs(a[x] - a[y]);
        cost3 += cal(len);
    }
    cost3 = min(cost3, 20);

    // 如果总价超过 50 元，则可以购买三日票
    long long ans = cost1 + cost2 + cost3;
    ans = min(ans, 50);

    if (t1 == 0 && t2 == 0 && t3 == 0) {
        // 懒狗是该沙漠！！！
        printf("Lazy, SkySummer!\n");
        printf("Lazy, SkySummer!\n");
        printf("Lazy, SkySummer!\n");
    } else {
        printf("%d", ans);
    }
    return 0;
}
```



## I 女巫的魔法

### 题目描述

在魔法世界，Zero 碰到了一名女巫，她可以施展魔法让被施法者变得强大，Zero 想要变得强大，所以他准备给女王送一些糖果来获得女巫的帮助，假设 Zero 有数不尽的糖果，而 Zero 并不知道送多少糖果女巫会满意，所以他选择第一次送 1 糖果，第二次送 2 个糖果，···， 第 $n$ 次送 $n$ 个糖果，直到女巫满意为止，假设你得知了女巫至少得到多少糖果就会满意，请你告诉 Zero 他至少需要送几次糖果女巫才会愿意为他施展魔法。

### 输入

一个正整数 $x$，代表女巫至少需要 $x$ 个糖果就会满意 $(~x~\le~10^{18}~)$

### 输出

一个整数 $y$，代表 Zero 至少需要送 $y$ 次糖果

### 提示

样例解释：女巫需要 5 个糖果，前 3 次 Zero 分别送了 1, 2, 3 个糖果，一共送了 6 个，满足 6 >= 5，所以需要送 3 次女巫才会满足（可以证明送糖果的次数小于 3 次时不满足条件）

### 样例输入

```markdown
5
```

### 样例输出

```markdown
3
```

### 题解

- 二分模版题，学长非常推荐大家学好二分，网上的二分模板特别多，一定要学会个自己能用好的（不然方到用时两行泪

- 首先我们可以看出不能暴力的枚举我们需要多少次，因为最坏的情况下，我们需要一个巨大的次数，然而枚举这个次数会导致程序时间超限，那就得想办法优化一下我们的代码

- 我们可以很直观的发现，满足情况的次数分布是有规律的：

  - 假设最优的答案为 ans，那么大于 ans 的次数都可以满足条件，小于 ans 的次数都不满足条件，也就是答案分布具有二段性
  - 解决这类问题最常用的方法就是二分

- 什么是二分呢？二分又命折半搜索，就是每次我们都能确定答案在当前区间的某一半，每次都能把搜素范围缩小一半，这样不断缩小范围，很快就能找到答案。那么我们该怎么确定答案在哪一半区间呢

- 最开始我们答案的区间一定是在 `[1, 1e10]` 的区间内的，因为 `1e10 * (1e10 + 1) / 2` >  `1e18` 的，故此 ans 一定在该范围内

- 设定 `l = 1, r = 1e10`，每次我们取出区间的中点 mid，对 mid 是否满足条件进行讨论：

  - 如果我们知道了送 mid 次是可以满足条件的，那么 ans 一定不会大于 mid，那么我们 ans 所在的区间变为 `[l, mid]`
  - 如果我们知道了送 mid 次是不满足条件的，那么 ans 一定会大于 mid，那么我们 ans 所在的区间变为 `[mid + 1, r]`
  - 之后不断重复这个过程，直到 `l == r`

- 这也就产生了如下的代码

  ```c
  long long l = 1, r = 1e10;
  while (l < r) {
  	long long mid = (l + r) / 2;
  	if (check(mid)) r = mid;  // check 函数用来判断 mid 是否满足要求
  	else l = mid + 1;
  }
  int ans = l; // 此时 l == r
  ```

- 那应该怎么判断 mid 是否成立呢，其实我们发现如果知道送糖果的次数 c，可以立马求出一共送了多少糖果

  - 根据等差数列求和公式 `sum = c * (c + 1) / 2`
  - 知道女巫需要 x 个糖果，我们只需要判断 `sum >= x?`

  ```c
  int check(long long c, long long x) {  
      if (c * (c + 1) / 2 >= x) {
  		return 1;
      } else {
          return 0;
      }   
  }
  ```

- 知道了这个思路就可以写出如下代码

```c
#include <stdio.h>

int check(long long c, long long x) {  
    if (c * (c + 1) / 2 >= x) {
		return 1;
    } else {
        return 0;
    }   
}

int main() {
    long long x;
    scanf("%lld", &x);

    long long l = 1, r = 1e10;
    while (l < r) {
	    long long mid = (l + r) / 2;
	    if (check(mid, x)) r = mid;  // check 函数用来判断 mid 是否满足要求
	    else l = mid + 1;
    }
    int ans = l; // 此时 l == r
    printf("%d", ans);
    return 0;
}
```