#include<bits/stdc++.h>
#define endl '\n'
#define deg(a) cout<<#a<<'='<<a<<"\n"
#define de(a) cout<<#a<<'='<<a<<' '
#define all(a) a.begin(),a.end()
#define ff first
#define ss second
//#define int long long 
using ll = long long;
const int N = 1e4+10,INF=0x3f3f3f3f;
using namespace std;
int dp[N],m=0;
char s1[N],s2[N];
//近似于01背包问题，遇到背包问题不要开二维数组，容易被卡
void solve() {
	scanf("%s%s",s1+1,s2+1);
	int l1=strlen(s1+1),l2=strlen(s2+1);
	for(int x=1;x<=l1;x++){
		//遍历字符（物品）
		for(int y=l2;y>=1;y--){//为什么逆序，01背包为什么都是逆序？这里再次讨论，若逆序遍历，
			//那么更新使用的是上层的前一位的数据，若正序，每一处的前一位都是由这一层的前一位所
			//更新的，对于每件物品，01背包下我们只有一个，接下来遍历合适的容器，若正序，第一个
			//容器合适，应该装进去，第二个容器也合适，其由第一个容器的属性更新，相当于又装进去
			//物品不能装两遍；若逆置，如果遇到同样适合的容器，我们取上一层的状态更新，我们可以
			//理解为每一次都是第一次遇见这个物品，每一个相同的容器都是循环的开始，因为循环开始
			//用的数据都是上一层留下的，本层并未影响，所有可以近似认为，每个容器都是该物品的绝
			//绝对有者（bushi）
			//遍历字符（容器：：背包问题中应该为容量，但这一题我认为容器更合适）
			if(s1[x]==s2[y]&&isalpha(s1[x])&&isalpha(s2[y])){
				//物品契合容器，同时满足是物品（为字母）
				//此时dp容纳的是价值属性，这里为字串长度
			   dp[y]=dp[y-1]+1;	
			   //综上，若满足判断情况，由于dp[y-1]也是判断过的，所以我们假定认为dp[y-1]也和物品
			   //照应，不难得出dp[y]=dp[y-1]+1;	
			   //当然谁知道dp[y-1]在上一层找到契合的物品了呢？所以假定没找到，dp[y-1]必须为0，这样
			   //dp[y]就是新的开始，即字符串的首端，由此可得不满足情况dp[y]应为0,便于下一层的使用
			   //其实在感觉上就是每出现一个不等就是一个转折点，将其清0方便新的开始
			   // 1 2 3 5 6 2 4
			   // 0 2 3 5 1 3 5
			   //建议直接模拟一下，这里不多做赘述，想拉好长时间没想出来怎么叙述，还是模拟大法好
			}
			else dp[y]=0;
			//不满足该物品不选，该循环下此容器处dp为0
			m=max(m,dp[y]);
		}
	}
	cout<<m;
}
signed main () {
	ios::sync_with_stdio(0), cin.tie(0);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
