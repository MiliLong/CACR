//01背包
#include<bits/stdc++.h>
using namespace std;
void solve() {
	int n, v ;//n为物品数，v为体积；
	cin >> n >> v ;
	int a[n + 1], b[n + 1], f[v + 1] ;
	memset( f, 0, sizeof f ) ;
	for ( int x = 1 ; x <= n ; x++ ) {
		cin >> a[x] ;//体积；
		cin >> b[x] ;//价值；
	}
	for (int x = 1; x <= n; x++) {
		for (int y = v; y >= a[x]; y--) {
			f[y] = max(f[y], f[y - a[x]] + b[x]);
		}
	}
	//第一层为遍历每件物品在各个体积中的选与不选的抉择的效果；
	//第二层即为在各个体积下的最优结果；
	//与完全背包的区别在于第二层的遍历01是从最大容积开始递减遍历的，目的为防止重复使用物品；
	/*
	假设物品编号1~n
	i号物品重量w[i]
	i号物品价值v[i]
	以下分析基于dp[4]（新）=dp[3]+v[2] dp[5]=dp[4]（旧）+v[2]
	0-1背包使用的倒叙遍历就是为了避免重复使用同一个物品。
	1.先从反面说明，假设使用顺序遍历，dp[4]（新）=dp[3]+v[2] ,
	dp[5]=dp[4]（新）+v[2] 将dp[4]带入dp[5]可以得到dp[5]=dp[3]+2*v[2]即会使用到2个2号物品，不满足0-1背包的要求，即每个物品只使用一次。
	2.使用倒叙为什么可以？
	因为我们每次先更新的都是后面的元素，当在计算dp[5]时实际的dp[4]还没有更新，还是之前的状态，这种情况下，我们就最多只能使用到一次当前的2号元素，
	即dp[5]=dp[4]（旧）+v[2] 。假设dp[4]（旧）=dp[2]+v[1](使用1号元素更新的数据）
	带入dp[5]可以得到dp[5]=dp[2]+v[1]+v[2]，可以发现，dp[5]中并不存在重复的情况。其他位置元素类似。
	你可能会想如果是dp[4](旧）=dp[3]（旧旧）+v[2]（旧旧）呢，这不就又是使用了两次v[2]了吗，但是实际上我们每次都是取的一个元素然后判断它放的位置，
	所以v[2]的使用必然在一次循环中，而我们使用的倒序，是先从后面开始的所以在dp[5]使用v[2]之前，dp[4]（旧）是不可能使用到v[2]的，实际使用的v[2]旧旧（即v[2]旧的上一层）。
	*/
	cout << f[v];
}
int main () {
	ios::sync_with_stdio(0), cin.tie(0);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
