#include<bits/stdc++.h>
#define endl '\n'
#define deg(a) cout<<#a<<'='<<a<<"\n"
#define de(a) cout<<#a<<'='<<a<<' '
#define all(a) a.begin(),a.end()
#define ff first
#define ss second
#define PII pair<int ,int>
#define int long long 
const int N = 1e5+10,INF=0x3f3f3f3f;
using namespace std;
int n,f[10],Max=0;
string s;
//f数组下标代表以该下标数为结尾的最长序列的长度
//其实f应为二维数组，横坐标代表选择第几个数来探讨，纵坐标同上
//对于每次选择，由于纵坐标的意义，每一次选择我们对整体中存在的以纵坐标数字为结尾的内容更新状态，此次我们选择的若符合则加一//，否则则不变,dp[i][b] = max(dp[i - 1][b], dp[i - 1][a] + 1),a为首，b为尾，为了让新的组末尾为b
//我们可以找前一个轮回末尾为b的，和此轮回找前一个轮回末尾为a的和该数组合形成新的轮回末尾为b的，新旧轮回的进行取max，以便之后轮回像前一轮回索取信息时始终是最大值，
//整体思想就是每新拿一个数，看看能不能和已有的序列结合，由于已有的序列其实可归结为长度和尾数，而且才10种尾数，所以我们都可以存起来，
//由这些信息我们就知道能不能配出新序列，能不能更新老序列，又由于序列是有顺序的，那么我们也需要按先来后到的顺序读数更新状态
//由上我们可整体理解此dp思想，那么接下来我们考虑优化
//这里将二维dp压缩为一维，由上可知我们是按顺序更新的，那么其实我们可以边读边更新，因为后面的内容对我们前面的内容没有用处
//又由我们取二维数组来存状态，每一个横坐标的那一行其实是存储着以各种数字为结尾的最长序列的长度，
//但在具体过程中我们其实不需要之前的那些存储的数据，每次更新我们都取最新的数据，老数据是落后被淘汰的
//所以我们其实只用开一个一维数组始终维护最新的数据就行
//每一次读入，我们也只会引用两个数据，以b结尾的老轮回的长度，以a结尾的但能和新b结合成新的以b为结尾的新轮回的老轮回的长度，我们可以实时维护更新这一层的信息，过程中维护最长序列即可，最后n-max得出答案
void solve() {
    cin>>n;
    for(int x=1;x<=n;x++){
       cin>>s;
       int a=s[0]-'0',b=s.back()-'0';
       f[b]=max(f[b],f[a]+1);
       Max=max(Max,f[b]);
    }
    cout<<n-Max<<endl;
}
signed main () {
    ios::sync_with_stdio(0), cin.tie(0);
    int t = 1;
    //cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
